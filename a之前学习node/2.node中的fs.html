<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title></title>
    <style>

    </style>
</head>

<body>
    fs:
    node内置的fs模块就是文件系统模块，负责读写文件 和所有其他js模块不同，fs模块同时提供了异步和同步的方法 

    回顾一下，什么是异步的方法：因为js是单线程模型，执行IO操作时，JS代码无需等待，而是传入回调函数后，继续执行后续的JS代码
    如：jQ中的$.getJSON(){}方法， $.getJSON('url',function(){ IO结果返回周执行这个函数，异步处理数据 })； 
    console.log(不等待IO结果直接执行这里的代码
    如果是同步，那么会等到IO结果获取到之后才执行这里的代码)


    1.readFile读取文件

    fs.readFile() 文件的读取，默认是异步的 
    fs.readFile(
    '第一个参数是文件的绝对路径或者当前同路径下的文件'， 
    '第二个参数是编码格式，二进制或者utf-8', 
    function(){ 第三个参数是回调函数 }) 

    **同步读取文件
    fs.readFileSync('文件路径'，'编码格式') 
    它不接受回调函数，函数直接返回结果 
    即：
        var data=fs.readFileSync('simple.text','utf-8');
        console.log(data)->获取的数据
    <script>
        'use strict'
        var fs = require('fs');
        fs.readFild('sample.txt', 'utf-8', function(err, data) {
            //异步读取时，传入的回调函数接受两个参数
            if (err) {
                //当读取发生错误时，err参数代表一个错误对象，data为undefined

                console.log(err);
            } else {
                //当正常读取时，err参数为null，data参数为读取到的String
                console.log(data)
            }
        })


        //同步读取时，如果发生错误，用
        try{
            //接收到数据走这里
            var data=fs.readFileSync('example.txt','utf-8');
            console.log(data);

        }catch(err){
            //没接收到走这里
            console.log(err);
        }

    </script>

    2.writeFile
    <script>
        writeFile()的参数依次为：写入数据的文件名，数据，回调函数
        var fs=require('fs');
        var data='b.js'
        fs.writeFile('a.js',data,function(err){
            回调函数只关心成功与否，因此只需要一个err参数
            if (err) {
                console.log(err);
            }else{
                console.log('ok');
            }
        })
    </script>
    和readFile()类似，writeFile()也有一个同步方法：
    writeFileSync()
    <script>
        'use strict'
        var fs=require('fs');
        var data='a.js';
        fs.writeFileSync('b.js',data);

    </script>
    
</body>

</html>